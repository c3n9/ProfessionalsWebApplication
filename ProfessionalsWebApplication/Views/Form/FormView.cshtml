@using ProfessionalsWebApplication.Models
@model FormModel

@{
	ViewData["Title"] = Model.Name;
}
<head>
	<link href="/styles/style.css" rel="stylesheet" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
</head>

<form method="post" enctype="multipart/form-data" id="form" class="w">
	<h2>@Model.Name</h2>
	@foreach (var question in Model.Questions)
	{
		@if (question.Type == "Text")
		{
			<div class="input-container">
				<input type="text" class="form-control no-digits" name="@question.Text" id="question-@question.Id" @(question.IsRequired ? "required" : "") placeholder=" " />
				<label for="question-@question.Id" class="floating-label">
					@question.Text.TrimEnd(':')
				</label>
				@if (!string.IsNullOrWhiteSpace(question.Note))
				{
					<p class="note">@question.Note</p>
				}
			</div>
		}
		else if (question.Type == "Button" && question.Options != null && question.IsDropDown == false)
		{
			<div class="toggle-full">
				<label for="question-@question.Id">@question.Text</label>
				<div class="toggle-buttons">
					@foreach (var option in question.Options)
					{
						<input type="radio" name="@question.Text" value="@option" id="option-@question.Id-@option" @(question.IsRequired ? "required" : "") />
						<label class="toggle-button" for="option-@question.Id-@option">@option</label>
					}
				</div>
			</div>
		}
		else if (question.Type == "Button" && question.Options != null && question.IsDropDown == true)
		{
			<div class="custom-select-container">
				<select class="custom-select" name="@question.Text" id="question-@question.Id" @(question.IsRequired ? "required" : "")>
					<option value="" disabled selected hidden></option>
					@foreach (var option in question.Options)
					{
						<option value="@option">@option</option>
					}
				</select>
				<label class="select-placeholder">@question.Text.TrimEnd(':')</label>
				<div class="select-arrow">▼</div>
			</div>
		}
		else if (question.Type == "File")
		{
			<div class="file-upload" data-question-id="@question.Id">
				<label>@question.Text</label>
				<label class="upload-area" for="file-upload-@question.Id">
					<div class="upload-icon">
						<svg width="50" height="50" viewBox="0 0 50 50" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M25 31.125V4.58331M25 4.58331L31.125 11.7291M25 4.58331L18.875 11.7291" stroke="#1C5493" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" />
							<path d="M16.834 45.4167H33.1673C38.9411 45.4167 41.8301 45.4167 43.6227 43.6241C45.4173 41.8274 45.4173 38.9425 45.4173 33.1667V31.125C45.4173 25.3512 45.4173 22.4643 43.6227 20.6696C42.0547 19.1016 39.6496 18.9036 35.209 18.8791M14.7923 18.8791C10.3517 18.9036 7.94661 19.1016 6.37861 20.6696C4.58398 22.4643 4.58398 25.3512 4.58398 31.125V33.1667C4.58398 38.9425 4.58398 41.8295 6.37861 43.6241C6.99111 44.2366 7.73019 44.6388 8.66732 44.9042" stroke="#1C5493" stroke-width="3" stroke-linecap="round" />
						</svg>
					</div>
					<div class="upload-text">Перетащите файлы или нажмите для выбора</div>
					<div class="format-hint">@question.Note</div>
					<input type="file" id="file-upload-@question.Id" class="file-input" name="@question.DisplayText" accept="@question.Note" @(question.IsRequired ? "required" : "")>
				</label>

				<div class="uploaded-files">
					<div class="uploaded-files-title">Загруженные файлы</div>
					<div class="file-list" id="file-list-@question.Id">
						<!-- Файлы будут добавляться здесь -->
					</div>
				</div>
			</div>
		}
	}

	<button type="submit" class="ripple-button">Отправить</button>
</form>

<script src="https://cdn.jsdelivr.net/npm/jsencrypt@3.0.0-rc.1/bin/jsencrypt.min.js"></script>
<script>
	document.addEventListener('DOMContentLoaded', function() {
		// Инициализация всех загрузчиков файлов
		const fileUploads = document.querySelectorAll('.file-upload');

		fileUploads.forEach(uploadContainer => {
			const questionId = uploadContainer.getAttribute('data-question-id');
			const fileInput = uploadContainer.querySelector('.file-input');
			const fileList = uploadContainer.querySelector('.file-list');
			const uploadArea = uploadContainer.querySelector('.upload-area');

			// Обработчик изменения файлов
			fileInput.addEventListener('change', function() {
				updateFileList(this, fileList);
			});

			// Обработчики drag and drop
			uploadArea.addEventListener('dragover', function(e) {
				e.preventDefault();
				this.classList.add('dragover');
			});

			uploadArea.addEventListener('dragleave', function(e) {
				e.preventDefault();
				this.classList.remove('dragover');
			});

			uploadArea.addEventListener('drop', function(e) {
				e.preventDefault();
				this.classList.remove('dragover');

				fileInput.files = e.dataTransfer.files;
				updateFileList(fileInput, fileList);
			});

			// Инициализация при наличии файлов (если нужно сохранять при перезагрузке)
			if (fileInput.files.length > 0) {
				updateFileList(fileInput, fileList);
			}
		});

		// Функция обновления списка файлов
		function updateFileList(input, fileListContainer) {
			// Очищаем список
			fileListContainer.innerHTML = '';

			// Добавляем каждый файл
			Array.from(input.files).forEach((file, index) => {
				const fileItem = document.createElement('div');
				fileItem.className = 'file-item';
				fileItem.dataset.fileIndex = index;

				fileItem.innerHTML = `
                    <div>
                        <span class="file-icon">📄</span>
                        <span class="file-name">${file.name}</span>
                        <span class="file-size">(${formatFileSize(file.size)})</span>
                    </div>
                    <button class="remove-file" title="Удалить">×</button>
                `;

				fileListContainer.appendChild(fileItem);

				// Обработчик удаления файла
				const removeBtn = fileItem.querySelector('.remove-file');
				removeBtn.addEventListener('click', function() {
					removeFileFromList(input, fileListContainer, index);
				});
			});
		}

		// Функция удаления файла из списка
		function removeFileFromList(input, fileListContainer, index) {
			const newFiles = Array.from(input.files).filter((_, i) => i !== index);

			// Создаем новый FileList
			const dataTransfer = new DataTransfer();
			newFiles.forEach(file => dataTransfer.items.add(file));

			// Обновляем input
			input.files = dataTransfer.files;

			// Обновляем список
			updateFileList(input, fileListContainer);

			// Если файлов не осталось, сбрасываем required (если нужно)
			if (newFiles.length === 0 && input.hasAttribute('required')) {
				input.setCustomValidity('Пожалуйста, выберите файл');
			} else {
				input.setCustomValidity('');
			}
		}

		// Форматирование размера файла
		function formatFileSize(bytes) {
			if (bytes === 0) return '0 Bytes';
			const k = 1024;
			const sizes = ['Bytes', 'KB', 'MB', 'GB'];
			const i = Math.floor(Math.log(bytes) / Math.log(k));
			return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
		}
	});

	// Функция для преобразования ArrayBuffer в base64
	function arrayBufferToBase64(buffer) {
		let binary = '';
		const bytes = new Uint8Array(buffer);
		const len = bytes.byteLength;
		for (let i = 0; i < len; i++) {
			binary += String.fromCharCode(bytes[i]);
		}
		return window.btoa(binary);
	}

	// Новая функция отправки формы с base64
	document.getElementById('form').onsubmit = async function(event) {
		event.preventDefault();

		const formData = new FormData(document.getElementById('form'));
		const data = { Answers: {} };
		const filePromises = [];

		// 1. Генерируем случайный AES-ключ и IV (Initialization Vector)
		const aesKey = crypto.getRandomValues(new Uint8Array(32)); // 256-битный ключ
		const aesIv = crypto.getRandomValues(new Uint8Array(16)); // 128-битный IV

		// 2. Шифруем AES-ключ с помощью RSA
		const rsa = new JSEncrypt();
		const publicKey = `
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApg2xMiBZY7y+F73l31Ke
7OPWIkaCHk847QZo+dOTkeb98+iP+z3AOViCK18lWikLthlCoIGaDcKPRrVL8faK
vbzv43Ka12i/eZIbp7JW4ek/I1bRdYd41coHmdD3HEbs56goUJBVBcHGuePH0yca
835Dx/AdxueLGOLgoSi+vyGaRQf4sMGjoRyMrm9OF8ougIXbfGij9b7i0kUPjifc
Dr3znK5gAeawHWRDzjHs5CJkAcs4ybqDRI8XSaXRag2r4fj9LwsG3jFO4OzGv6cf
bf6TwQHHpD9In9474oVg5kuXPghpwWbG0euckBmVyzWs+sMx9sB/IKe19tZu7+3N
PQIDAQAB
-----END PUBLIC KEY-----
`.trim();
		rsa.setPublicKey(publicKey);
		const encryptedAesKey = rsa.encrypt(JSON.stringify({
			Key: arrayBufferToBase64(aesKey),
			Iv: arrayBufferToBase64(aesIv)
		}));

		// 3. Обрабатываем все поля формы
		for (const [key, value] of formData.entries()) {
			if (value instanceof File) {
				const filePromise = new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onloadend = async () => {
						try {
							// 1. Преобразуем файл в base64 (как в C#)
							const fileBase64 = arrayBufferToBase64(reader.result);

							// 2. Шифруем строку base64 (не raw-байты!)
							const encoder = new TextEncoder();
							const encodedBase64 = encoder.encode(fileBase64); // Преобразуем строку в Uint8Array

							const encryptedFile = await crypto.subtle.encrypt(
								{ name: 'AES-CBC', iv: aesIv },
								await crypto.subtle.importKey('raw', aesKey, 'AES-CBC', false, ['encrypt']),
								encodedBase64 // Шифруем base64-строку как байты
							);

							// 3. Результат шифрования преобразуем в base64
							const encryptedBase64 = arrayBufferToBase64(encryptedFile);

							data.Answers[key] = {
								FileName: value.name,
								FileSize: value.size,
								FileContent: encryptedBase64 // Отправляем на сервер
							};
							resolve();
						} catch (error) {
							reject(`Ошибка шифрования файла: ${error}`);
						}
					};
					reader.onerror = () => reject('Ошибка чтения файла');
					reader.readAsArrayBuffer(value);
				});
				filePromises.push(filePromise);
			}else {
				// Шифруем текстовые поля с помощью AES
				const textEncoder = new TextEncoder();
				const encodedValue = textEncoder.encode(value);
				const encryptedValue = await crypto.subtle.encrypt(
					{ name: 'AES-CBC', iv: aesIv },
					await crypto.subtle.importKey('raw', aesKey, 'AES-CBC', false, ['encrypt']),
					encodedValue
				);
				// Преобразуем в base64
				const encryptedBase64 = arrayBufferToBase64(encryptedValue);
				data.Answers[key] = encryptedBase64;
			}
		}

		// 4. Отправляем данные на сервер
		await Promise.all(filePromises);
		submitEncrypted({
			FormId: '@Model.Id',
			Data: JSON.stringify(data),
			Key: encryptedAesKey
		});
	};

	async function submitEncrypted(data) {
		try {
			const response = await fetch('/forms/submit', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(data)
			});
			const result = await response.json();
			if (result.redirectUrl) window.location.href = result.redirectUrl;
		} catch (error) {
			console.error('Ошибка отправки:', error);
			alert('Ошибка при отправке формы');
		}
	}
</script>